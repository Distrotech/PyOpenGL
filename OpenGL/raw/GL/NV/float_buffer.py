'''OpenGL extension NV.float_buffer

Overview (from the spec)
	
	This extension builds upon NV_fragment_program to provide a framebuffer
	and texture format that allows fragment programs to read and write
	unconstrained floating point data.
	
	In unextended OpenGL, most computations dealing with color or depth
	buffers are typically constrained to operate on values in the range [0,1].
	Computational results are also typically clamped to the range [0,1].
	Color, texture, and depth buffers themselves also hold values mapped to
	the range [0,1].
	
	The NV_fragment_program extension provides a general computational model
	that supports floating-point numbers constrained only by the precision of
	the underlying data types.  The quantites computed by fragment programs do
	not necessarily correspond in number or in range to conventional
	attributes such as RGBA colors or depth values.  Because of the range and
	precision constraints imposed by conventional fixed-point color buffers,
	it may be difficult (if not impossible) to use them to implement certain
	multi-pass algorithms.
	
	To enhance the extended range and precision available through fragment
	programs, this extension provides floating-point RGBA color buffers that
	can be used instead of conventional fixed-point RGBA color buffers.  A
	floating-point RGBA color buffer consists of one to four floating-point
	components stored in the 16- or 32-bit floating-point formats (fp16 or
	fp32) defined in the NV_half_float and NV_fragment_program extensions.
	
	When a floating-point color buffer is used, the results of fragment
	programs, as written to the "x", "y", "z", and "w" components of the
	o[COLR] or o[COLH] output registers, are written directly to the color
	buffer without any clamping or modification.  Certain per-fragment
	operations are bypassed when rendering to floating-point color buffers.
	
	A floating-point color buffer can also be used as a texture map, either by
	reading back the contents and then using conventional TexImage calls, or
	by using the buffer directly via the ARB_render_texture extension.
	
	This extension has many uses.  Some possible uses include:
	
	    (1) Multi-pass algorithms with arbitrary intermediate results that
	        don't have to be artifically forced into the range [0,1].  In
	        addition, intermediate results can be written without having to
	        worry about out-of-range values.
	
	    (2) Deferred shading algorithms where an expensive fragment program is
	        executed only after depth testing is fully complete.  Instead, a
	        simple program is executed, which stores the parameters necessary
	        to produce a final result.  After the entire scene is rendered, a
	        second pass is executed over the entire frame buffer to execute
	        the complex fragment program using the results written to the
	        floating-point color buffer in the first pass.  This will save the
	        cost of applying complex fragment programs to fragments that will
	        not appear in the final image.
	
	    (3) Use floating-point texture maps to evaluate functions with
	        arbitrary ranges.  Arbitrary functions with a finite domain can be
	        approximated using a texture map holding sample results and
	        piecewise linear approximation.
	
	There are several significant limitations on the use of floating-point
	color buffers.  First, floating-point color buffers do not support frame
	buffer blending.  Second, floating-point texture maps do not support
	mipmapping or any texture filtering other than NEAREST.  Third,
	floating-point texture maps must be 2D, and must use the
	NV_texture_rectangle extension.

The official definition of this extension is available here:
	http://oss.sgi.com/projects/ogl-sample/registry/NV/float_buffer.txt

Automatically generated by the get_gl_extensions script, do not edit!
'''
from OpenGL import platform, constants, constant, arrays
from OpenGL import extensions
from OpenGL.GL import glget
import ctypes
EXTENSION_NAME = 'GL_NV_float_buffer'
GL_FLOAT_R_NV = constant.Constant( 'GL_FLOAT_R_NV', 0x8880 )
GL_FLOAT_RG_NV = constant.Constant( 'GL_FLOAT_RG_NV', 0x8881 )
GL_FLOAT_RGB_NV = constant.Constant( 'GL_FLOAT_RGB_NV', 0x8882 )
GL_FLOAT_RGBA_NV = constant.Constant( 'GL_FLOAT_RGBA_NV', 0x8883 )
GL_FLOAT_R16_NV = constant.Constant( 'GL_FLOAT_R16_NV', 0x8884 )
GL_FLOAT_R32_NV = constant.Constant( 'GL_FLOAT_R32_NV', 0x8885 )
GL_FLOAT_RG16_NV = constant.Constant( 'GL_FLOAT_RG16_NV', 0x8886 )
GL_FLOAT_RG32_NV = constant.Constant( 'GL_FLOAT_RG32_NV', 0x8887 )
GL_FLOAT_RGB16_NV = constant.Constant( 'GL_FLOAT_RGB16_NV', 0x8888 )
GL_FLOAT_RGB32_NV = constant.Constant( 'GL_FLOAT_RGB32_NV', 0x8889 )
GL_FLOAT_RGBA16_NV = constant.Constant( 'GL_FLOAT_RGBA16_NV', 0x888A )
GL_FLOAT_RGBA32_NV = constant.Constant( 'GL_FLOAT_RGBA32_NV', 0x888B )
GL_TEXTURE_FLOAT_COMPONENTS_NV = constant.Constant( 'GL_TEXTURE_FLOAT_COMPONENTS_NV', 0x888C )
GL_FLOAT_CLEAR_COLOR_VALUE_NV = constant.Constant( 'GL_FLOAT_CLEAR_COLOR_VALUE_NV', 0x888D )
glget.addGLGetConstant( GL_FLOAT_CLEAR_COLOR_VALUE_NV, (4,) )
GL_FLOAT_RGBA_MODE_NV = constant.Constant( 'GL_FLOAT_RGBA_MODE_NV', 0x888E )
glget.addGLGetConstant( GL_FLOAT_RGBA_MODE_NV, (1,) )


def glInitFloatBufferNV():
	'''Return boolean indicating whether this extension is available'''
	return extensions.hasGLExtension( EXTENSION_NAME )
