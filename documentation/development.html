<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>











  
  
  
  
  
  
  
  
  
  
  
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">











  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <title>Contributing to PyOpenGL 3.x</title><link rel="stylesheet" type="text/css" href="style/tutorial.css">











  
  
  
  
  
  
  
  
  
  
  
  <meta name="author" content="Mike C. Fletcher"></head>
<body>











<h1>Contributing
to PyOpenGL 3.x<br>











</h1>











<p class="introduction">This
document describes how to get started with
contributing to the PyOpenGL 3.x release series.&nbsp; It outlines the
basic
architecture of the system and how to begin work on the system for a
new developer.&nbsp; It assumes familiarity with Python, Numpy and
ctypes.<br>











</p>











<h2>The History of PyOpenGL 3.x<br>











</h2>











<p>PyOpenGL 3.x is a
re-implementation of the OpenGL bindings
for Python.&nbsp; Historically there were two other mainline
implementations of OpenGL for Python.</p>











<ul>











  <li>PyOpenGL up to 1.x was
written as a C extension using the raw
Python C API.&nbsp; It was characterised by a very intuitive
"Pythonic"
API that just seemed to do what you expected it to do (in most cases)
because the authors had actually sat down and written the code for
every function.&nbsp; Maintenance and extension was extremely hard,
and
support for extensions was minimal or non-existant.&nbsp; This is
the
code base originally created by David Ascher et. al.&nbsp; This
code
base has been entirely superceded by PyOpenGL 2.x.<br>











  </li>











  <li>PyOpenGL 2.x was written as
a set of SWIG typemaps (a.k.a.
PyOpenGLSWIG.&nbsp; The code was basically a huge set of nested
macro
expansions, SWIG pattern matching rules and a heavily hacked distutils
script that semi-automatically turned OpenGL headers into usable C
extensions.&nbsp; PyOpenGL 2.x had far greater support for
extensions
and far better coverage than the 1.x series, but it was extremely
difficult to modify or debug the system.&nbsp; It was also
notoriously
difficult to compile/install.&nbsp; This is the codebase created by
Tarn Weisner Burton.</li>











</ul>If you are interested in the
rationale for the rewrite, see <a href="http://blog.vrplumber.com/989">this posting</a>,
which outlines
why the reimplementation was undertaken.























<h2>Getting the Code</h2>











<p>PyOpenGL 3.x is developed and
maintained on the <a href="https://launchpad.net/">LaunchPad</a> site.&nbsp; To branch
the current version of PyOpenGL:</p>











<pre>bzr branch lp:pyopengl<br>bzr branch lp:pyopengl-demo<br></pre>











<p>You will need to add the pyopengl/OpenGL directory to your PYTHONPATH to work directly from the checkout.<br>











</p><p>When you have changes you would like to work on, either post
them to your LaunchPad account and request a merge into PyOpenGL's
trunk, or generate a merge-set with:</p><pre>bzr send -o my-patch.diff<br></pre><p>And send it to the <a href="https://lists.sourceforge.net/lists/listinfo/pyopengl-devel">PyOpenGL-dev mailing list</a> or <a href="mailto:mcfletch@vrplumber.com">Mike Fletcher</a>.</p>











<h2>The Architecture of PyOpenGL 3.x</h2>











<p>Here are the loose design goals
of PyOpenGL 3.x:</p>











<ul>











  <li>Access to the all of
OpenGL's functionality</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Allow access to OpenGL 1.x, 2.x and 3.x functionality</li>











    <li>Access to (all) modern extensions</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>Backward compatability with
PyOpenGL code</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Not a fanatic requirement,
but most legacy code should run
without changes</li><li>All legacy code should run with minor changes only</li>











    <li>Insulate the PyOpenGL
developer from the implementation (ctypes) so that code can continue to
work across multiple implementations</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>Ease of development</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>The whole point of this is
to make it possible for more people
to work on the system</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>Play nicely with others</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Alternate Python
implementations (PyPy, IronPython)</li>











    <li>GUI libraries</li>











    <li>Numeric libraries</li>











    <li>Threading behaviour</li>











    <li>Multimedia libraries</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>Flexibility and robustness</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Graceful degradation in
the face of missing functionality</li>











    <li>Ease of debugging</li>











    <li>Informative error reports</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>Ease of installation</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Portability (note, we are
limited to ctypes ported platforms,
but that should grow faster than we grow, given that ctypes is now part
of Python)<br>











    </li>











    <li>Simplicity of installation
process (no hacked up distutils!)</li>











    <li>Use of eggs and easy_install</li>











    <li>Ability to plug in support for new data-types and the like</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











</ul>











<h3>Platform Abstraction</h3>











<p class="introduction">PyOpenGL is exposing "platform" (Operating
System and Hardware) functionality to the Python environment.&nbsp;
Differences among the various platforms are abstracted such that
porting PyOpenGL to a new platform is largely a matter of
implementing a small module in the "platform" sub-package.</p>











<p>Each platform gets their own <code>OpenGL.platform.baseplatform.BasePlatform</code> subclass.&nbsp; <a href="pydoc/OpenGL.platform.baseplatform.html"><code>OpenGL.platform.baseplatform.BasePlatform</code></a> classes provide:</p>











<ul>











  <li>ctypes library objects for
GL, GLU, GLUT and possibly GLE. How we
find these libraries, the names of the libraries, flags needed for
loading and the like tends to be system specific</li>











  <li>definition of the ctypes <code>FunctionType</code>
used for
calling functions in the libraries, i.e. what calling convention to use
for calling the functions.&nbsp; On Windows, for instance, we have to
use windows, rather than C calling conventions.<br>











  </li>











  <li>functions <code>GetCurrentContext()</code>
and <code>CurrentContextIsValid()</code>
to allow code to retrieve and/or test whether we have a current
context.&nbsp; This is used to implement context-specific
data-storage.&nbsp; These are normally exposed by the platform's
OpenGL
implementation<br>











  </li>











  <li>function <code>getExtensionProcedure(
name )</code> to retrieve
an OpenGL extension function by name</li>











  <li>function <code>getGLUTFontPointer(
constant )</code> to retrieve
a <code>void *</code>
to a GLUT font, different platforms use very
different conventions for these values</li>











  <li>flags <code>HAS_DYNAMIC_EXT</code>
and <code>EXT_DEFINES_PROTO</code>
which tell PyOpenGL 3.x whether the platform has the ability to load
dynamic extensions and whether it uses prototype definitions</li>











  <li>function safeGetError() to retrieve OpenGL's error state if doing
so would be safe (i.e. we have a valid context or the platform can
handle having a call to glGetError when there is no valid context)</li>
  <li>functions/methods
to create/retrieve function pointers from libraries (createBaseFunction
and createExtensionFunction), which insulate us from changes in
ctypes as well as giving us a convenient
place to add functionality to any function.
    <pre><code>def createBaseFunction( <br>&nbsp;&nbsp;&nbsp; functionName, dll=OpenGL, <br>&nbsp;&nbsp;&nbsp; resultType=ctypes.c_int, argTypes=(),<br>&nbsp;&nbsp;&nbsp; doc = None, argNames = (),<br>):</code><br></pre>











    <p>and</p>











    <pre><code>def createExtensionFunction( <br>	functionName, dll=OpenGL,<br>	resultType=ctypes.c_int, <br>	argTypes=(),<br>	doc = None, argNames = (),<br>):</code></pre>











  </li>











</ul>











<p>New platform implementations are registered in&nbsp;<code>setup.py</code>
using pkgtools entry points. &nbsp;We use the sys.platform and os.name
(in that order of preference) to decide which entry point to load.</p>











<h3>Autogenerated Wrappers</h3>











<p>There are two major wrapper generator systems available for use with
ctypes. &nbsp;Originally PyOpenGL 3.x used the ctypes generator module
(based on GCC-XML) to produce its wrappers. &nbsp;We are switching to
using the <code>pyglet/tools/wraptypes</code> module, but have not yet got a working version of this generator. &nbsp;Extension
modules are currently created via a regex-based generator, eventually
we'll switch to using wraptypes for that work as well.</p>
<h4>wraptypes Generator (new method, not finished)</h4>
<p>The
primary value of wraptypes is that it is easy to install and configure,
and allows for parsing headers which are not "native" to the platform
on which they are being run. &nbsp;The wrapper generator (<code>gengl.py</code>) is not as advanced/finished as the <code>openglgenerator.py</code>
module, but it can generate the platform-specific module quite nicely,
and the underlying code is under active development with a focus on
GL-related operations.</p>
<p>To run this generator, simple check out pyglet's svn repository and add the tools/wraptypes package to your <code>PYTHONPATH</code>, then run the <code>src/gengl.py</code> module in PyOpenGL's source tree.</p>
<h4>ctypes Wrapper Generator (old method, broken)</h4>
<p>ctypes includes a mechanism
based on GCC-XML which will autogenerate
wrappers for many C libraries. PyOpenGL 3.x uses an
extended&nbsp;version of this autogenerator (in the src subdirectory of
the CVS
repository, see <code>generateraw.py</code> and <code>openglgenerator.py</code>) to produce the C-style "raw" API for the core libraries. &nbsp;These are the modules in the <code>OpenGL.raw</code> packages. &nbsp;If you wish to use ctypes directly with a C-style API it is possible to directly import and use these modules.</p>




<p>The generator also produces "annotations" modules in each of the
raw.* packages. &nbsp;These contain calls which wrap the base functions
in size-of-array-aware wrappers. &nbsp;The constants from the module
are also split into a separate module for easier reading (this module
is then imported into the main module).</p>




<p>Much of the API for the core libraries can be
used
as-is from the <code>raw</code> packages, so the main package modules
normally import all symbols from their <code>raw.XXX</code>
and <code>raw.XXX.annotations</code> module
before importing from modules providing customised functionality.</p><p>This method has been broken as the ctypes generator has changed since we produced our (extensive diffs).</p><h4>OpenGL Extension Generation</h4>








<p>Unlike the core modules,
extension modules are auto-generated using
a low-level hack that downloads the OpenGL extension registry's current
header file and parses the file with regexes, matching the two
definitions so that it can generate a single <code>createExtensionFunction</code>
call that has all of the data-type and naming information for that
function.</p>











<p class="technical">The
OpenGL extension definitions in the <code>glext.h</code>
header are split into two parts, a macro which retrieves the pointer to
the function, and the function itself.&nbsp; One of the definitions
provides the parameter list, the other provides the
properly-capitalised name.&nbsp; We need both to use the function.</p>











<p class="technical">A consequence of this approach is that PyOpenGL 3.x can remain up-to-date for OpenGL extensions.&nbsp;
Producing the raw versions of all new extensions is normally just a
single command away.<br>











</p>











<p>glGet() output arrays are handled specially by the
auto-generation.&nbsp; It produces calls which register constants
against array sizes so that the glGet* family of calls can return the
correctly-sized array for a given constant.&nbsp; It does this by
combining information from the specification documents and the size
specifications stored in the glgetsizes.csv document in the source
directory.</p>











<p>The autogeneration process also attempts to copy the "Overview"
section of the specification for each module into the docstring of the
module, so that users and coders can readily identify the purpose of
the module.</p>











<p>The extension modules are
written as a single file, with the code
for the auto-generated material placed above a comment line which
tells you not to edit above it.</p>











<pre>### DO NOT EDIT above the line "END AUTOGENERATED SECTION" below!<br>...<br>### END AUTOGENERATED SECTION</pre>











<p>Customisations of the extension
are done after the auto-generated
section.&nbsp; This (single file approach) is done mostly to reduce
the
number of files in the project and to make it easier to hack on a
single extension.</p>











<p class="technical">It is
expected and encouraged that users will hack
on an extension module they care about to make it more Pythonic and
then contribute the changes back to the project.</p>











<p>If you remove the autogenerated
comment then further autogeneration
passes will not process the module, keep in mind, however, that
improvements to the extension autogeneration will likely occur over
time.</p>











<h3>Converters and Wrappers</h3>











<p>When a method cannot use the
autogenerated ctypes wrapper as-is, we
normally fall back to the <code><a href="pydoc/OpenGL.wrapper.html">OpenGL.wrapper</a>.Wrapper</code>
class,
and the converters defined in the <a href="pydoc/OpenGL.converters.html"><code>OpenGL.converters</code></a>
module.&nbsp; The Wrapper class provides a set of argument
transformation stages which allow for composing most functions from a
common set of simple operations.</p>











<p class="technical">This
approach will seem familiar to those who have
looked at the source code generated by systems such as SWIG.&nbsp;
There you define a set of matching rules which include snippets of code
which are composed into the C function being compiled.&nbsp;
Instead of
rule-based matching, we use explicit specification.</p>











<p>In some cases it's just easier
to code up a custom wrapper function
that uses raw ctypes.&nbsp; We can do so without a problem simply
by
including the code in the namespace with the appropriate name. &nbsp;The lazy wrapper (described below) can make this easier.</p>











<h4>Wrapper Objects</h4>











<p>The stages in the Wrapper call
are as follows:</p>











<ol>











  <li>pyConverters -- accept (or
suppress) incoming Python arguments</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Used to convert a Python
argument to a type which is compatible
with the expected data-type</li>











    <li>Can be used to eliminate
an argument from the argument list by
passing no function, this is useful when we want to imply an argument
from the structure of another argument, for instance</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>cConverters -- pull
C-compatible argument out of the Python
argument list</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Looks at the whole set of
Python argument and produces a 1:1
argument list of Python objects for the ctypes call</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>cResolvers -- take the
C-compatible Python objects and turn them
into the low-level data-type required by the ctypes call</li>











  <li>ctypes call, (with error
checking, errors are annotated with the
arguments used during the call)</li>











  <li>storeValues -- called to
store a C-compatible Python object, for
instance to prevent garbage collection of an array that is in-use</li>











  <li>returnValues -- determines
what result is required from the
wrapped function</li>











</ol>











<p>Of particular interest is the method <code>wrapper.Wrapper.setOutput</code>
which allows you to generate output arrays for a function using a
passed-in size tuple, dictionary or function to determine the
appropriate size for the
array.&nbsp; See the <a href="pydoc/OpenGL.GL.glget.html"><code>OpenGL.GL.glget</code></a>
module for examples of usage.</p>











<h4>Converters</h4>











<p>The <a href="pydoc/OpenGL.converters.html"><code>OpenGL.converters</code></a>
module provides a number of conversion "functions" for use with the
wrapper module's Wrapper objects.&nbsp; The idea of these converter
functions is to produce readily re-used code that describes a common
idiom in wrapping a function.&nbsp; The core libraries and
extensions then use these idioms to simplify the wrapping of their
functions.</p><h4>Lazy Wrapping</h4><p>It
is often desirable to write a small piece of wrapper code in python and
then just call the base operation. &nbsp;You can use the
OpenGL.lazywrapper module's "lazy" wrapper to accomplish this. &nbsp;It
passes the base operation as the first argument when calling the
function which is decorated. &nbsp;Example usage:</p><pre>@lazy( glGetInfoLogARB )<br>def glGetInfoLogARB( baseOperation, obj ):<br>	"""Retrieve the program/shader's error messages as a Python string<br>	<br>	returns string which is '' if no message<br>	"""<br>	length = int(glGetObjectParameterivARB(obj, GL_INFO_LOG_LENGTH_ARB))<br>	if length &gt; 0:<br>		log = ctypes.create_string_buffer(length)<br>		baseOperation(obj, length, None, log)<br>		return log.value.strip('\000') # null-termination<br>	return ''</pre>











<h3>Array Handling</h3>











<p class="introduction">While
you can do a great deal of work with OpenGL without array operations,
Python's OpenGL interfaces are all fastest when you use array (or
display-list) techniques to push as much of your rendering work into
the platform implementation as possible.&nbsp; As such, the natural
handling of arrays is often a key issue for OpenGL programmers.
&nbsp;Display-lists are deprecated, so their use isn't advisable.</p>











<p>Perhaps the most complex
mechanisms in PyOpenGL 3.x are those which implement the array-based
operations which allow for using low-level blocks of formatted data to
communicate with the OpenGL implementation.&nbsp; PyOpenGL 3.x
preferred basic array implementation is the (new) numpy
reimplementation of the original Numeric Python.</p>











<p>The array handling
functionality provided within PyOpenGL 3.x is localised to the <a href="pydoc/OpenGL.arrays.html"><code>OpenGL.arrays</code></a>
sub-package.&nbsp; Within the package, there are two major classes,
one (the <a href="pydoc/OpenGL.arrays.formathandler.html"><code>FormatHandler</code></a>)
which implements an interface to a way of storing data in Python, and
another (the <a href="pydoc/OpenGL.arrays.__init__.html"><code>ArrayDatatype</code></a>)
which models an OpenGL array format.&nbsp; The <code>ArrayDatatype</code>
classes use <code>FormatHandler</code>s
to manipulate array-compatible objects for use in the system.</p>











<h4>ArrayDatatypes</h4>











<p>ArrayDatatype classes provide <a href="pydoc/OpenGL.arrays.__init__.html#ArrayDatatype">an
API</a> composed primarily of
classmethods (that is, methods which are called directly on the class,
rather than requiring an instance of the class).&nbsp; The
classmethods are used throughout PyOpenGL 3.x to provide
array-format-specific handling of Python arguments.</p>











<p>Currently we have the following
array types defined:</p>











<ul>











  <li>ArrayDatatype</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Used for generic array
operations</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>GLclampdArray</li>











  <li>GLclampfArray</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Clamped floating-point
types</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>GLfloatArray</li>











  <li>GLdoubleArray</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Un-clamped floating-point
types</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>GLbyteArray</li>











  <li>GLcharArray (GLcharARBArray) <br>











  </li>











  <li>GLubyteArray</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Character arrays</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>GLshortArray</li>











  <li>GLintArray</li>











  <li>GLsizeiArray</li>











  <li>GLenumArray</li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Integer array types<br>











    </li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











</ul>











<p>When you are coding new PyOpenGL 3.x modules, you should always use the ArrayDatatype
interfaces.&nbsp; These interfaces allow us to code generic
operations such that they dispatch to the appropriate format handlers.</p>











<h4>Format Handlers<br>











</h4>











<p>Each format handler is
responsible for implementing an API that ArrayDatatypes can use to work
with the Python data-format.&nbsp; Data-formats can support a
subset of the API, they only need to support those aspects of the
data-format which make sense.&nbsp; For instance, a write-only
array data-type (such as a Python string) doesn't need to implement the
<code>zeros</code> method.</p>











<p>At the moment we have the
following Format Handlers:</p>











<ul>











  <li><a href="pydoc/OpenGL.arrays.nones.html"><code>nones.NoneHandler</code></a></li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Supports passing the None
object as an array data-pointer, quite limited in its functionality</li>











    <li>Implemented in Python</li>











    <li>registered as: 'nones'</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li><a href="pydoc/OpenGL.arrays.numpymodule.html"><code>numpymodule.NumpyHandler</code></a>,
(<a href="pydoc/OpenGL.arrays.numarrays.html"><code>numarrays.NumarrayHandler</code></a>,&nbsp;<a href="pydoc/OpenGL.arrays.numeric.html"><code>numeric.NumericHandler)</code></a><br>











  </li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Full data-format handlers
for the three Numeric Python implementations</li>











    <li>numpy module is
implemented in Python using a stable API</li>

    <li>Numeric module is implemented in Python using a bit of a hack</li>

    <li>Numarray currently requires a C extension and, at the
moment, is not built by default</li>











    <li>registered as: 'numpy' and 'numeric' ('numarray')</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li><a href="pydoc/OpenGL.arrays.numbers.html"><code>numbers.NumberHandler</code></a></li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Supports passing single
Python integers/floats in as array data-types</li>











    <li>Does not currently support
use for output arguments (since Numeric arrays are currently used for
single-value output arrays)</li>











    <li>Implemented in Python</li>











    <li>registered as: 'numbers'</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li><a href="pydoc/OpenGL.arrays.strings.html"><code>strings.StringHandler</code></a></li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Supports using Python
strings as data-sources, no output support</li>











    <li>Implemented in Python (with a bit of a hack in _strings.py)<br>











    </li>











    <li>registered as: 'strings'</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>











  <li><a href="pydoc/OpenGL.arrays.ctypesarrays.html">ctypesarrays.CtypesArrayHandler</a>,
    <a href="pydoc/OpenGL.arrays.ctypespointers.html">ctypespointers.CtypesPointerHandler</a></li>











  
  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Full data-format handler for ctypes arrays, input-only for
pointers</li>











    <li>Implemented in Python</li>











    <li>registered as: 'ctypesarrays','ctypespointers'</li>











  
  
  
  
  
  
  
  
  
  
  
  </ul>







  <li>lists.ListHandler</li>







  
  
  
  
  
  
  
  <ul>







    <li>Backup supports for using Python lists/tuples as data-sources if there is no numpy module available</li>







    <li>registered as 'lists'</li>







  
  
  
  
  
  
  
  </ul>











</ul>











<h5>Registering new FormatHandlers</h5>











<p>PyOpenGL 3.x&nbsp;uses the simplistic OpenGL.plugins module which allows
you to register a plugin instance which defines a class which is to be
loaded to handle a given data format.</p>
<pre>from OpenGL.plugins import FormatHandler<br>FormatHandler( 'numpy', 'OpenGL.arrays.numpymodule.NumpyHandler', ['numpy.ndarray'] )</pre>
<p>The first parameter is just a name used to refer to the plugin.
&nbsp;The second is the actual class to load. &nbsp;If there is not
third parameter, then the plugin will automatically load. &nbsp;If
there is a value, then the value is a&nbsp;list of module.classname
values which will be matched against incoming array-parameter values.</p>
<p>PyOpenGL 3.x&nbsp;delays resolving the FormatHandler set until the last
possible moment (i.e. the first call is made which requires a
FormatHandler).&nbsp; Any time before this you can use code like this
to declare your application's preference for the handler to be used for
creating output argument (this handler must define a <code>zeros(...)</code>
method):</p>











<pre>from OpenGL.arrays import formathandler<br>formathandler.FormatHandler.chooseOutput( 'ctypesarrays' )</pre>











<p>Where the strings passed are those under which the handler was
registered (see previous section).</p>











<p class="technical">There are currently no C-level extension modules
in PyOpenGL 3.x.&nbsp; However, we have (disabled) implementations for
a few format handlers which are C extensions.&nbsp; It should be
possible to rewrite each of these as pure Python code using ctypes
eventually.&nbsp; They were written as C extensions simply because
I had the code handy and I didn't want to have to re-specify the
structures for every release of Python or numpy.&nbsp; The _strings.py
module is an example of a how such a rewrite could be done.&nbsp; It
does a test at
run-time to determine the offset required to get a data-pointer from a
Python string.</p>











<h3>Image Handling</h3>











<p>Most of the complexity of Image
handling is taken care of by the Array Handling functionality, as most
image data-types are simply arrays of data in a given format.&nbsp;
Beyond that, it is necessary to set various OpenGL parameters so that
the data-format assumptions of most Python users (e.g. tightly packed
image data) will be met.</p>











<p>The <a href="pydoc/OpenGL.images.html"><code>OpenGL.images</code></a>
module has the basic functions and data-tables which allow for
processing image data (both input and output).&nbsp; Eventually we
will add APIs to support registering new image-types, but for now we
have to directly modify the data-tables to register a new data-type.</p>











<p>The <a href="pydoc/OpenGL.GL.images.html"><code>OpenGL.GL.images</code></a>
module has implementations of the core OpenGL image-manipulation
functions which use the OpenGL.images module.&nbsp; It can serve as
an example of how to use the image handling mechanisms.</p>











<h3>Error Handling</h3>











<p>As with previous versions of
PyOpenGL, PyOpenGL 3.x tries to follow Python's</p>











<p class="introduction">Errors
should never pass silently. </p>











<p>philosophy, rather than
OpenGL's philosophy of always requiring explicit checks for error
conditions.&nbsp; PyOpenGL 3.x functions run the function <code>OpenGL.error.glCheckError</code>
after each function call.&nbsp; This function is glBegin/glEnd
aware, that is, the glBegin and glEnd functions enable and disable the
checking of errors (because error checking doesn't work between those
calls).</p>











<p>You can override the error-handler, either to provide your own
custom functionality, or to disable checking entirely.&nbsp; For
instance, if you will always have a valid context, you could register
the raw glGetError function as the error checker to avoid the overhead
of the context-validity checks:</p>











<pre>from OpenGL import error<br>error.ErrorChecker.registerChecker( myAlternateFunction )</pre>











<p>PyOpenGL 3.x&nbsp;has a set of
errors defined in the <a href="pydoc/OpenGL.error.html"><code>OpenGL.error</code></a>
module.&nbsp; It can also raise standard Python exceptions, such as
ValueError or TypeError.&nbsp; Finally, it can raise ctypes errors
when argument conversion fails. (XXX that's sub-optimal, it has
implementation details poking out to user code).<br>











</p>











<p>Wrapper objects catch OpenGL
errors and annotate the error with extra information to make it easier
to debug failures during the wrapping process.</p>











<h3>Context-specific Data</h3>











<p>Because of the way OpenGL and
ctypes handle, for instance, pointers, to array data, it is often
necessary to ensure that a Python data-structure is retained (i.e. not
garbage collected).&nbsp; This is done by storing the data in an
array of data-values that are indexed by a context-specific
key.&nbsp; The functions to provide this functionality are provided
by the <a href="pydoc/OpenGL.contextdata.html"><code>OpenGL.contextdata</code></a>
module.</p>











<p class="technical">The
key that is used to index the storage array is provided by the platform
module's <code>GetCurrentContext()</code>
function.&nbsp; The current context is used if the context argument
is passed in as <code>None</code>.<br>











</p>











<p>You can store a new value for
the current context with a call to:</p>











<pre>def setValue( constant, value, context=None, weak=False ):<br>	"""Set a stored value for the given context"""</pre>











<p>You can retrieve the current
value (which will return None if there is no currently set value) with
a call to:</p>











<pre>def getValue( constant, context = None ):<br>	"""Get a stored value for the given constant"""</pre>











<p>Lastly, you can delete any
currently set value with:</p>











<pre>def delValue( constant, context=None ):<br>	"""Delete the specified value for the given context"""</pre>











<p>which will return a boolean
telling you whether an existing value was found.</p>











<p class="technical">Keep
in mind that you must either explicitly clear out each stored value or
explicitly clear out the stored data with a call to <code>OpenGL.contextdata.cleanupContext</code>
when you destroy a rendering context.</p>











<h3>Extensions</h3>











<p>The OpenGL extension mechanism
is quite well developed, with most new functionality appearing as an
extension before it migrates into the OpenGL core.&nbsp; There are
hundreds of registered extensions to OpenGL, with a large fraction of
the extensions simply introducing new constants or a few new simple
functions.</p>











<p>A few of the largest
extensions, such as the <a href="pydoc/OpenGL.GL.ARB.shader_objects_new.html"><code>GL.ARB.shader_object</code></a>
or <a href="pydoc/OpenGL.GL.ARB.vertex_buffer_object.html"><code>GL.ARB.vertex_buffer_object</code></a>
extensions are more involved in their effects on the system.&nbsp;
These extensions require considerable custom code beyond that generated
by the auto-generation system. &nbsp;These wrapper modules are stored
in the OpenGL.GL.* hierarchy, while the raw generated APIs are in the
OpenGL.raw.* hierarchy.</p><p class="footer">&nbsp;
<a href="http://pyopengl.sourceforge.net/"><img alt="PyOpenGL" src="images/pyopengl_icon.jpg" style="border: 0px solid ; width: 32px; height: 32px;" align="middle"></a>A
SourceForge Open-Source project: <a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=5988&amp;type=1" style="border: 0px solid ; width: 88px; height: 31px;" alt="SourceForge" align="middle"></a></p>











</body></html>